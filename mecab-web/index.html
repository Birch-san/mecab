<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Mecab WebAssembly</title>
	<style>
		.emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
		div.emscripten { text-align: center; }      
		div.emscripten_border { border: 1px solid black; }
		/* the canvas *must not* have any border or padding, or mouse coords will be wrong */
		canvas.emscripten { border: 0px none; background-color: black; }
		
		.spinner {
			height: 30px;
			width: 30px;
			margin: 0;
			margin-top: 20px;
			margin-left: 20px;
			display: inline-block;
			vertical-align: top;
		
			-webkit-animation: rotation .8s linear infinite;
			-moz-animation: rotation .8s linear infinite;
			-o-animation: rotation .8s linear infinite;
			animation: rotation 0.8s linear infinite;
		
			border-left: 5px solid rgb(235, 235, 235);
			border-right: 5px solid rgb(235, 235, 235);
			border-bottom: 5px solid rgb(235, 235, 235);
			border-top: 5px solid rgb(120, 120, 120);
    	
			border-radius: 100%;
			background-color: rgb(189, 215, 46);
		}
		
		@-webkit-keyframes rotation {
			from {-webkit-transform: rotate(0deg);}
			to {-webkit-transform: rotate(360deg);}
		}
		@-moz-keyframes rotation {
			from {-moz-transform: rotate(0deg);}
			to {-moz-transform: rotate(360deg);}
		}
		@-o-keyframes rotation {
			from {-o-transform: rotate(0deg);}
			to {-o-transform: rotate(360deg);}
		}
		@keyframes rotation {
			from {transform: rotate(0deg);}
			to {transform: rotate(360deg);}
		}
		
		#status {
			display: inline-block;
			vertical-align: top;
			margin-top: 30px;
			margin-left: 20px;
			font-weight: bold;
			color: rgb(120, 120, 120);
		}
		
		#progress {
			height: 20px;
			width: 300px;
		}

		#output {
    	/*width: 100%;
    	height: 200px;*/
      width: 40em;
      height: 10em;

      border: black solid 1px;

    	/*margin: 0 auto;
    	margin-top: 10px;*/

      border-width: 1px;

    	/*border-left: 0px;
    	border-right: 0px;*/
    	padding-left: 0px;
    	padding-right: 0px;
    	display: block;
    	/*background-color: black;
    	color: white;*/
    	font-family: 'Lucida Console', Monaco, monospace;
    	outline: none;
      overflow-y: scroll;
      resize: both;
    }

    #input {
      width: 40em;
      height: 4em;
    }

    #args {
      width: 40em;
    }

    form input,form textarea {
      display: block;
    }

    textarea {
      font-size: 16px;
    }

    #richOutput {
      margin-top: 1em;
      font-size: 18px;
      font-weight: 600;
      word-spacing: 0.15em;
    }

    body {
      font-family: "Helvetica Neue", Helvetica, "Lucida Grande", sans-serif;
    }
	</style>
</head>
<body>
	<div class="spinner" id='spinner'></div>
    <div class="emscripten" id="status">Downloading...</div>

	<div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>
    </div>

    <h1>MeCab in WebAssembly</h1>
    <p><a href="https://taku910.github.io/mecab/">MeCab, the Japanese morphological analyser by Taku Kudo</a> compiled to WebAssembly by Alex Birch. References prior <a href="https://github.com/fasiha/mecab-emscripten">emscripten example by fasiha</a>.<br>Uses <a href="https://ja.osdn.net/projects/naist-jdic/wiki/FrontPage">NAIST-jdic</a> dictionary.<br>Uses <a href="https://github.com/WaniKani/WanaKana">WanaKana</a> for transliteration, additional tokenization, and classification.<br>
    
    <div><small>Licenses:</small></div>
<details>
  <summary><small>MeCab (BSD),</small></summary>
  See <a href="https://github.com/taku910/mecab/blob/master/mecab/COPYING">COPYING</a>.
<pre>
Copyright (c) 2001-2008, Taku Kudo
Copyright (c) 2004-2008, Nippon Telegraph and Telephone Corporation
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above
   copyright notice, this list of conditions and the
   following disclaimer.

 * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other
   materials provided with the distribution.

 * Neither the name of the Nippon Telegraph and Telegraph Corporation
   nor the names of its contributors may be used to endorse or
   promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
</details>
<details>
  <summary><small>NAIST-jdic (BSD),</small></summary>
  See <a href="https://ja.osdn.net/projects/naist-jdic/wiki/FrontPage#h2-NAIST-jdic.20.E3.81.A8.E3.81.AF">project front page</a>.<br>
  <blockquote>NAIST-jdic は、IPAdic の後継です。 IPAdic の固有名詞以外の全エントリをチェック（可能性に基づく品詞の整理）し、 表記ゆれ情報を付与し、複合語の構造を付与する作業を行っています。 固有名詞については不要な語、新規追加などの整理を随時行っていきます。 この作業により IPAdic のライセンスで問題となっていた ICOT 条項を削除し、 広告条項無しの BSD ライセンスに変更致しました。</blockquote>
<pre>
Copyright (c) 2009, Nara Institute of Science and Technology, Japan.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
Neither the name of the Nara Institute of Science and Technology
(NAIST) nor the names of its contributors may be used to endorse or
promote products derived from this software without specific prior
written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
</details>
<details>
  <summary><small>This work &ndash; mecab-web &ndash; (BSD),</small></summary>
  See <a href="https://github.com/Birch-san/mecab/blob/master/mecab-web/LICENSE">LICENSE</a>.
<pre>
Copyright (c) 2019, Alex Birch
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above
   copyright notice, this list of conditions and the
   following disclaimer.

 * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other
   materials provided with the distribution.

 * Neither the name of Alex Birch
   nor the names of contributors may be used to endorse or
   promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
</details>
<details>
  <summary><small>WanaKana (MIT).</small></summary>
  See <a href="https://github.com/WaniKani/WanaKana/blob/master/LICENSE">LICENSE</a>.
<pre>
The MIT License (MIT)

Copyright (c) 2013 WaniKani Community Github

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</pre>
</details>
<p>
MeCab suggests where to put spaces.<br>
MeCab suggests how to pronounce kanji words.<br>
MeCab deconjugates verbs, revealing the "dictionary form".
</p>
    <!-- <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div> -->
    <form id="form">
        <!-- <input id="args" name="args" value="-o output.txt input.txt" placeholder="-o output.txt input.txt"> -->
        <textarea id="input" name="input">
太郎はこの本を二郎を見た女性に渡した。
すもももももももものうち。
</textarea>
        <input id="submitter" type="submit" value="Analyse Japanese">
    </form>
    <!-- <pre id="output"></pre> -->
    <div id="richOutput"></div>

    <script type="text/javascript" src="lib/wanakana.min.js"></script>
    <script type='text/javascript'>
      const statusElement = document.getElementById('status');
      const progressElement = document.getElementById('progress');
      const spinnerElement = document.getElementById('spinner');
      const outputElement = document.getElementById('output');
      const richOutputElement = document.getElementById('richOutput');
      const wrapped = {};
      const toBeFreed = {
        mecab_model_t: new Set(), // config
        mecab_t: new Set(), // tagger
        mecab_lattice_t: new Set(),
      };
      let p_currentTagger;
      let p_currentLattice;

      /**
      I ended up not needing this in the end, but it does a cool thing:
      input:
      '取り引き'
      output:
      [
        [
          {type: 'kanji', value: '取'},
          {type: 'hiragana', value: 'り'},
        ],
        [
          {type: 'kanji', value: '引'},
          {type: 'hiragana', value: 'き'},
        ],
      ]
      */
      /*
      function chunkByKanji(token) {
        return wanakana.tokenize(token, { detailed: true })
        .reduce((accumulator, currentValue)=> {
          if (!accumulator.length) {
            return [[currentValue]];
          }
          if (currentValue.type === 'kanji') {
            // start a new segment
            return [...accumulator, [currentValue]];
          }
          // insert our token into latest segment
          return [
          ...accumulator.slice(0, accumulator.length-1),
          [...accumulator[accumulator.length-1], currentValue],
          ];
        },[]);
      }
      */

      /**
      I ended up not needing this in the end, but it does a cool thing:
      input:
      ('取り引き', 'とりひき')
      output:
      [
        [
          {type: 'kanji', value: '取', reading: 'と''},
          {type: 'hiragana', value: 'り'},
        ],
        [
          {type: 'kanji', value: '引', reading: 'ひ'},
          {type: 'hiragana', value: 'き'},
        ],
      ]
      */
      /*
      function withReadingsByKanjiChunk(token, readingHiragana) {
        const subtokens = wanakana.tokenize(token, { detailed: true });
        const regExStr = subtokens.reduce((accumulator, currentSubtoken) => {
          if (currentSubtoken.type === 'kanji') {
            return accumulator + '(.+)';
          }
          return accumulator + currentSubtoken.value;
        }, '^') + '$';

        const regEx = new RegExp(regExStr);
        const matches = regEx.exec(readingHiragana);

        return subtokens.reduce((accumulator, currentSubtoken) => {
          const [chunks, kanjiReadings] = accumulator;
          if (currentSubtoken.type === 'kanji') {
            // start a new chunk
            return [
              [
                ...chunks,
                [{
                  ...currentSubtoken,
                  reading: kanjiReadings[0],
                }]
              ],
              kanjiReadings.slice(1)
            ];
          }
          // insert our subtoken into latest chunk
          return [
            [
              ...chunks.slice(0, chunks.length-1),
              [
              ...chunks[chunks.length-1],
              currentSubtoken,
              ],
            ],
            kanjiReadings,
          ];
        }, [[], matches.slice(1)])[0];
      }
      */

      /**
      input:
      ('取り引き', 'とりひき')
      output:
      [
        {type: 'kanji', value: '取', reading: 'と''},
        {type: 'hiragana', value: 'り'},
        {type: 'kanji', value: '引', reading: 'ひ'},
        {type: 'hiragana', value: 'き'},
      ]
      */
      function toSubtokensWithKanjiReadings(token, readingHiragana) {
        const subtokens = wanakana.tokenize(token, { detailed: true });
        // if there's no kanji, then there's nothing to fit furigana to
        // and if there's anything other than kanji+hiragana, then our "strip okurigana" tactic won't work.
        if (!subtokens.some((subtoken) => ['kanji'].includes(subtoken.type))
          || subtokens.some((subtoken) => !['kanji', 'hiragana'].includes(subtoken.type))) {
          // console.error(`token ${token} has non-kanji or non-hiragana subtokens.`);
          // we're only interested in fitting a hiragana reading to kanji words that (may) have okurigana.
          // we're not interested in fitting our hiragana reading to a katakana or English word, for example.
          return subtokens;
        }
        const regExStr = subtokens.reduce((accumulator, currentSubtoken) => {
          if (currentSubtoken.type === 'kanji') {
            return accumulator + '(.+)';
          }
          return accumulator + currentSubtoken.value;
        }, '^') + '$';

        const regEx = new RegExp(regExStr);
        const matches = regEx.exec(readingHiragana);
        if (!matches) {
          console.error(`We were unable to match the hiragana reading '${readingHiragana}' to token '${token}'. We used RegExp /${regExStr}/.`);
          return subtokens;
        }

        return subtokens.reduce((accumulator, currentSubtoken) => {
          const [chunks, kanjiReadings] = accumulator;
          if (currentSubtoken.type === 'kanji') {
            return [
              [
                ...chunks,
                {
                  ...currentSubtoken,
                  reading: kanjiReadings[0],
                },
              ],
              kanjiReadings.slice(1)
            ];
          }
          return [
            [
              ...chunks,
              currentSubtoken,
            ],
            kanjiReadings,
          ];
        }, [[], matches.slice(1)])[0];
      }

      function parse(sentence) {
        const output = wrapped.mecab_sparse_tostr(p_currentTagger, sentence);
        console.log(output);
        return output.replace(/EOS\n$/, '')
        .split('\n')
        .filter(x => x)
        .map((line) => {
          const [token, featureStr] = line.split('\t');
          const features = featureStr.split(',');
          // MeCab seems to have a non-guaranteed schema
          while (features.length <= 9) {
            features.push('');
          }
          const [
          surfaceLayerForm, // 表層形
          partOfSpeech, // 品詞
          partOfSpeechSubcategory1, // 品詞細分類1
          partOfSpeechSubcategory2, // 品詞細分類2
          partOfSpeechSubcategory3, // 品詞細分類3
          utilizationType, // 活用型
          dictionaryForm, // 活用形
          originalForm, // 原形
          reading, // 読み
          pronunication, // 発音
          ] = features;
          const readingHiragana = wanakana.toHiragana(reading, { passRomaji: false });
          const subtokens = toSubtokensWithKanjiReadings(token, readingHiragana);
          // console.warn(subtokens);
          return {
            token,
            surfaceLayerForm,
            partOfSpeech,
            partOfSpeechSubcategory1,
            partOfSpeechSubcategory2,
            partOfSpeechSubcategory3,
            utilizationType,
            dictionaryForm,
            originalForm,
            reading,
            readingHiragana,
            subtokens,
            pronunication,
          }
        });
      }

      function createAnalysisFragment(nodes) {
        const fragment = document.createDocumentFragment();
        const div = document.createElement('div');
        let bufferedText = '';
        for (const node of nodes) {
          let isFirstSubtoken = true;
          for (const subtoken of node.subtokens) {
            if (subtoken.type === 'kanji') {
              if (bufferedText) {
                const trailingWhitespace = isFirstSubtoken ? ' ' : '';
                div.insertAdjacentText('beforeend', `${bufferedText}${trailingWhitespace}`);
                bufferedText = '';
              }
              const ruby = document.createElement('ruby');
              const rb = document.createElement('rb');
              const rt = document.createElement('rt');

              rb.textContent = subtoken.value;
              rt.textContent = subtoken.reading;
              ruby.appendChild(rb);
              ruby.appendChild(rt);
              div.appendChild(ruby);
            } else {
              const leadingWhitespace = isFirstSubtoken
              && !(['englishPunctuation', 'japanesePunctuation']
              .includes(subtoken.type))
              ? ' '
              : '';
              bufferedText += `${leadingWhitespace}${subtoken.value}`;
            }
            isFirstSubtoken = false;
          }
        }
        if (bufferedText) {
          div.insertAdjacentText('beforeend', bufferedText);
        }
        fragment.appendChild(div);
        return fragment;
      }

      document.getElementById('form').addEventListener('submit', function(event) {
        event.preventDefault();
        const input = document.getElementById('input').value;
        const nodes = parse(input);
        console.warn(nodes);
        // const pretty = nodes.map((node) => node.token).join('\n');
        // outputElement.insertAdjacentText('beforeend', `${pretty}\n`);
        // outputElement.scrollTop = outputElement.scrollHeight;

        const fragment = createAnalysisFragment(nodes);
        richOutput.prepend(fragment);
      }, true);

      const dicdir = '/naist-jdic';

      var Module = {
      	noInitialRun: true,
      	onRuntimeInitialized: function() {
          statusElement.style.display = 'none';
      	},
        locateFile: function(path, prefix) {
          console.log(path, prefix);
          // // if it's a mem init file, use a custom dir
          // if (path.endsWith(".mem")) return "https://mycdn.com/memory-init-dir/" + path;
          // otherwise, use the default, the prefix (JS file's dir) + the path
          return prefix + path;
        },
        preRun: [function() {
          FS.createPath('/', 'usr/local/etc')
          FS.writeFile('/usr/local/etc/mecabrc', `\
;
; Configuration file of MeCab
;
; $Id: mecabrc.in,v 1.3 2006/05/29 15:36:08 taku-ku Exp $;
;
dicdir = ${dicdir}

; userdic = /home/foo/bar/user.dic

; output-format-type = wakati
; input-buffer-size = 8192

; node-format = %m\n
; bos-format = %S\n
; eos-format = EOS\n
`);
        }],
        postRun: [function() {
          Object.assign(wrapped, {
            mecab_do: Module.cwrap('mecab_do2', 'number', ['string']),
            mecab_model_new2: Module.cwrap('mecab_model_new2', 'number', ['string']),
            mecab_model_destroy: Module.cwrap('mecab_model_destroy', null, ['number']),
            mecab_strerror: Module.cwrap('mecab_strerror', 'string', ['number']),
            mecab_model_new_tagger: Module.cwrap('mecab_model_new_tagger', 'number', ['number']),
            mecab_destroy: Module.cwrap('mecab_destroy', null, ['number']),
            mecab_nbest_sparse_tostr: Module.cwrap('mecab_nbest_sparse_tostr', 'string', ['number', 'number', 'string']),
            mecab_sparse_tostr: Module.cwrap('mecab_sparse_tostr', 'string', ['number', 'string']),
          });

          // we could probably skip the destroy since the world's ending anyway..
          Module.addOnExit(() => {
            toBeFreed.mecab_t.forEach((p_mecab_t) => {
              wrapped.mecab_destroy(p_mecab_t);
            });
            toBeFreed.mecab_model_t.forEach((p_mecab_model_t) => {
              wrapped.mecab_model_destroy(p_mecab_model_t);
            });
          });

          // const args = document.getElementById('args').value;
          // const args = '-o output.txt input.txt';
          const args = '';
          const p_mecab_model = wrapped.mecab_model_new2(args);
          toBeFreed.mecab_model_t.add(p_mecab_model);

          const p_tagger = wrapped.mecab_model_new_tagger(p_mecab_model);
          toBeFreed.mecab_t.add(p_tagger);

          p_currentTagger = p_tagger;

          document.getElementById('submitter').click();
        }],
        print: (function() {
          // var element = document.getElementById('output');
          // if (element) element.value = ''; // clear browser cache
          // return function(text) {
          //   if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          //   // These replacements are necessary if you render to raw HTML
          //   //text = text.replace(/&/g, "&amp;");
          //   //text = text.replace(/</g, "&lt;");
          //   //text = text.replace(/>/g, "&gt;");
          //   //text = text.replace('\n', '<br>', 'g');
          //   console.log(text);
          //   if (element) {
          //     element.value += text + "\n";
          //     element.scrollTop = element.scrollHeight; // focus on bottom
          //   }
          // };
            return function(text) {
              if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
              console.log(text);
              // FS.writeFile('output.txt', parts);
              const outputElem = document.getElementById('output');
              outputElem.insertAdjacentText('beforeend', `${text}\n`);
              outputElem.scrollTop = outputElem.scrollHeight
            };
        })(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          console.error(text);
        },
        // canvas: (function() {
        //   var canvas = document.getElementById('canvas');

        //   // As a default initial behavior, pop up an alert when webgl context is lost. To make your
        //   // application robust, you may want to override this behavior before shipping!
        //   // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
        //   canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

        //   return canvas;
        // })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) spinnerElement.style.display = 'none';
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
      window.onerror = function(event) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus('Exception thrown, see JavaScript console');
        spinnerElement.style.display = 'none';
        Module.setStatus = function(text) {
          if (text) Module.printErr('[post-exception status] ' + text);
        };
      };
    </script>
    <script async type="text/javascript" src="mecab.js"></script>
</body>
</html>